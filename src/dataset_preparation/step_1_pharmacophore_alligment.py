#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Pharmacophore label builder (explicit modes):

- k3:  1×HBA + 1×HBD + 1×aromatic
- k4:  auto-pick between:
       (A) 2×HBA + 1×HBD + 1×aromatic
       (B) 1×HBA + 1×HBD + 2×aromatic
- k5:  3×HBA + 1×HBD + 1×aromatic

Terminology (very important!):
- CONFORMER = specific 3D geometry of the same molecule. In SDF each record
  with name "...#conf=N" is a DIFFERENT conformer of the same ID.
- CONFIGURATION (assignment) = a choice of atoms that satisfy the pharmacophore
  (e.g. for k4_2HBA all combinations C(n_HBA, 2) × n_HBD × n_aromatic_groups).
  Configurations are generated by enum_* functions.

Algorithm per SDF:
- Group records by ID (molecule) regardless of #conf.
- For each ID iterate over its conformers (SDF records).
- For EVERY conformer generate all pharmacophore CONFIGURATIONS and check geometry.
- Collect unique matching configurations (atomic signature) across ALL conformers
  of that ID.
- Keep:
    * POSITIVES: ID with EXACTLY ONE unique configuration matched (y=1)
    * NEGATIVES: ID with ZERO matching configurations (y=0)
  Drop IDs with >1 distinct configurations (ambiguous pharmacophore).
- For y=1, store winner_conf_id (conformer where the FIRST unique match was found),
  original name, and matched_conf_ids (all conformers with any match).

Output:
- Per SDF: CSV with one row per ID:
    ID, smiles, y, HBA/HBD/aromatic (for the first unique configuration),
    sdf_source (absolute path to SDF),
    winner_conf_id, winner_name, matched_conf_ids, n_confs, n_matches.

Example:
  python build_labels.py \
      --part-dir sdf_files/part_000 \
      --plots-root plots \
      --out-root labels_out \
      --pharm k4 \
      --cpus 8 \
      --hypo-json hypothesis/k4.json \
      --log-level DEBUG \
      --log-configs
"""

import os
import sys
import glob
import logging
import argparse
import json
import re
from typing import Dict, List, Tuple, Optional
from concurrent.futures import ProcessPoolExecutor, as_completed
import itertools
import numpy as np
import pandas as pd

from rdkit import Chem
from rdkit.Chem import ChemicalFeatures
from rdkit import RDConfig
from rdkit.Chem.Draw import rdMolDraw2D

# =============================================================================
# Logging
# =============================================================================
def setup_logging(level: str):
    lvl = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(level=lvl, format="%(asctime)s | %(levelname)s | %(message)s")
    logging.getLogger().setLevel(lvl)


# =============================================================================
# RDKit feature factory / constants
# =============================================================================
_ff = ChemicalFeatures.BuildFeatureFactory(
    os.path.join(RDConfig.RDDataDir, "BaseFeatures.fdef")
)
_HALOGENS = {9, 17, 35, 53}
_CONF_RE = re.compile(r"([^#]+)#conf=(\d+)")


# =============================================================================
# Exceptions & validators
# =============================================================================
class PharmacophoreSpecError(AssertionError):
    pass


def _is_tuple3(x):
    return (
        isinstance(x, (list, tuple))
        and len(x) == 3
        and all(isinstance(v, (int, float)) for v in x)
    )


def _validate_coords_list(name, pts):
    if pts is None:
        return
    if not isinstance(pts, list):
        raise PharmacophoreSpecError(
            f"'{name}' must be a list of (x,y,z); got {type(pts).__name__}"
        )
    for i, p in enumerate(pts):
        if not _is_tuple3(p):
            raise PharmacophoreSpecError(
                f"'{name}[{i}]' must be a 3-tuple of numbers; got {p}"
            )


def validate_runtime_params(tol_core: float, tol_ar: float):
    if tol_core < 0 or tol_ar < 0:
        raise PharmacophoreSpecError(
            f"Tolerances must be ≥ 0 (got tol_core={tol_core}, tol_ar={tol_ar})."
        )


def ensure_has_conformer(mol: Chem.Mol, id_hint: str = ""):
    if mol is None or mol.GetNumConformers() == 0:
        raise PharmacophoreSpecError(
            f"Molecule {id_hint or ''} has no conformer(s)."
        )


# =============================================================================
# Geometry helpers
# =============================================================================
def _p(conf, i: int) -> np.ndarray:
    v = conf.GetAtomPosition(int(i))
    return np.array([v.x, v.y, v.z], float)


def _d(a: np.ndarray, b: np.ndarray) -> float:
    return float(np.linalg.norm(a - b))


# =============================================================================
# RDKit utilities
# =============================================================================
def fused_aromatic_groups(mol: Chem.Mol) -> List[List[int]]:
    """Return lists of atom indices for each fused aromatic system."""
    m = Chem.RemoveHs(mol)
    aro_atoms = {a.GetIdx() for a in m.GetAtoms() if a.GetIsAromatic()}
    if not aro_atoms:
        return []

    from collections import defaultdict

    adj = defaultdict(list)
    for b in m.GetBonds():
        if b.GetIsAromatic():
            i, j = b.GetBeginAtomIdx(), b.GetEndAtomIdx()
            if i in aro_atoms and j in aro_atoms:
                adj[i].append(j)
                adj[j].append(i)

    seen, groups = set(), []
    for a in sorted(aro_atoms):
        if a in seen:
            continue
        comp, stack = [], [a]
        seen.add(a)
        while stack:
            v = stack.pop()
            comp.append(v)
            for w in adj[v]:
                if w not in seen:
                    seen.add(w)
                    stack.append(w)
        groups.append(sorted(comp))
    return groups


def get_HBD_heavy(mol: Chem.Mol) -> List[int]:
    """
    Donors (N/O/S with attached H) – return indices of heavy atoms.
    """
    mh = Chem.AddHs(mol)
    donors = set()
    for a in mh.GetAtoms():
        Z = a.GetAtomicNum()
        if Z in (7, 8, 16) and any(n.GetAtomicNum() == 1 for n in a.GetNeighbors()):
            donors.add(a.GetIdx())
    return sorted(donors)


def get_HBA_heavy(mol: Chem.Mol) -> List[int]:
    """
    Acceptors from RDKit FeatureFactory, with simple filtering
    (no halogens, no positively charged N).
    """
    mh = Chem.AddHs(mol)
    feats = _ff.GetFeaturesForMol(mh)
    acc = {int(f.GetAtomIds()[0]) for f in feats if f.GetFamily() == "Acceptor"}
    out = []
    m = Chem.RemoveHs(mol)
    for i in sorted(acc):
        ai = m.GetAtomWithIdx(i)
        Z = ai.GetAtomicNum()
        if Z in _HALOGENS:
            continue
        if Z == 7 and ai.GetFormalCharge() > 0:
            continue
        out.append(i)
    return out


# =============================================================================
# Distance specs
# =============================================================================
def distances_k3(hipo):
    _validate_coords_list("HBA", hipo.get("HBA"))
    _validate_coords_list("HBD", hipo.get("HBD"))
    _validate_coords_list("aromatic", hipo.get("aromatic"))
    if len(hipo["HBA"]) < 1 or len(hipo["HBD"]) < 1 or len(hipo["aromatic"]) < 1:
        raise PharmacophoreSpecError("k3 needs ≥1 HBA, ≥1 HBD, ≥1 aromatic")
    A, D, R = hipo["HBA"][0], hipo["HBD"][0], hipo["aromatic"][0]

    def dist(a, b):
        return float(np.linalg.norm(np.array(a) - np.array(b)))

    return {"A_D": dist(A, D), "R_A": dist(R, A), "R_D": dist(R, D)}


def distances_k4_ha2(hipo):
    if len(hipo["HBA"]) < 2 or len(hipo["HBD"]) < 1 or len(hipo["aromatic"]) < 1:
        raise PharmacophoreSpecError("k4(2HBA) needs ≥2 HBA, ≥1 HBD, ≥1 aromatic")
    A1, A2 = hipo["HBA"][0], hipo["HBA"][1]
    D = hipo["HBD"][0]
    R = hipo["aromatic"][0]

    def dist(a, b):
        return float(np.linalg.norm(np.array(a) - np.array(b)))

    return {
        "HA1_HA2": dist(A1, A2),
        "HA1_HD": dist(A1, D),
        "HA2_HD": dist(A2, D),
        "Ar_HA1": dist(R, A1),
        "Ar_HA2": dist(R, A2),
        "Ar_HD": dist(R, D),
    }


def distances_k4_ar2(hipo):
    if len(hipo["HBA"]) < 1 or len(hipo["HBD"]) < 1 or len(hipo["aromatic"]) < 2:
        raise PharmacophoreSpecError("k4(2Ar) needs ≥1 HBA, ≥1 HBD, ≥2 aromatic")
    A = hipo["HBA"][0]
    D = hipo["HBD"][0]
    R1, R2 = hipo["aromatic"][0], hipo["aromatic"][1]

    def dist(a, b):
        return float(np.linalg.norm(np.array(a) - np.array(b)))

    return {
        "A_D": dist(A, D),
        "R1_A": dist(R1, A),
        "R1_D": dist(R1, D),
        "R2_A": dist(R2, A),
        "R2_D": dist(R2, D),
        "R1_R2": dist(R1, R2),
    }


def distances_k5_ha3(hipo):
    if len(hipo["HBA"]) < 3 or len(hipo["HBD"]) < 1 or len(hipo["aromatic"]) < 1:
        raise PharmacophoreSpecError("k5 needs ≥3 HBA, ≥1 HBD, ≥1 aromatic")
    A1, A2, A3 = hipo["HBA"][0], hipo["HBA"][1], hipo["HBA"][2]
    D = hipo["HBD"][0]
    R = hipo["aromatic"][0]

    def dist(a, b):
        return float(np.linalg.norm(np.array(a) - np.array(b)))

    return {
        "HA1_HA2": dist(A1, A2),
        "HA1_HA3": dist(A1, A3),
        "HA2_HA3": dist(A2, A3),
        "HA1_HD": dist(A1, D),
        "HA2_HD": dist(A2, D),
        "HA3_HD": dist(A3, D),
        "Ar_HA1": dist(R, A1),
        "Ar_HA2": dist(R, A2),
        "Ar_HA3": dist(R, A3),
        "Ar_HD": dist(R, D),
    }


# =============================================================================
# Enumerators (pharmacophore CONFIGURATIONS for a given conformer)
# =============================================================================
def enum_k3(mol: Chem.Mol) -> List[Dict[str, List[int]]]:
    HBD = get_HBD_heavy(mol)
    HBA = get_HBA_heavy(mol)
    arom_groups = fused_aromatic_groups(mol)
    out = []
    for a in HBA:
        for d in HBD:
            if arom_groups:
                for ar in arom_groups:
                    out.append({"HBA": [a], "HBD": [d], "aromatic": ar})
            else:
                out.append({"HBA": [a], "HBD": [d], "aromatic": []})
    return out


def enum_k4_ha2(mol: Chem.Mol) -> List[Dict[str, List[int]]]:
    HBD = get_HBD_heavy(mol)
    HBA = get_HBA_heavy(mol)
    arom_groups = fused_aromatic_groups(mol)
    out = []
    for ha1, ha2 in itertools.combinations(HBA, 2):
        for hd in HBD:
            if arom_groups:
                for ar in arom_groups:
                    out.append({"HBA": [ha1, ha2], "HBD": [hd], "aromatic": ar})
            else:
                out.append({"HBA": [ha1, ha2], "HBD": [hd], "aromatic": []})
    return out


def enum_k4_ar2(mol: Chem.Mol) -> List[Dict[str, List[int]]]:
    HBD = get_HBD_heavy(mol)
    HBA = get_HBA_heavy(mol)
    arom_groups = fused_aromatic_groups(mol)
    out = []
    if len(arom_groups) < 2:
        return out
    for a in HBA:
        for d in HBD:
            for ar1, ar2 in itertools.combinations(arom_groups, 2):
                out.append({"HBA": [a], "HBD": [d], "aromatic_pair": (ar1, ar2)})
    return out


def enum_k5_ha3(mol: Chem.Mol) -> List[Dict[str, List[int]]]:
    HBD = get_HBD_heavy(mol)
    HBA = get_HBA_heavy(mol)
    arom_groups = fused_aromatic_groups(mol)
    out = []
    if len(HBA) < 3:
        return out
    for ha1, ha2, ha3 in itertools.combinations(HBA, 3):
        for hd in HBD:
            if arom_groups:
                for ar in arom_groups:
                    out.append(
                        {"HBA": [ha1, ha2, ha3], "HBD": [hd], "aromatic": ar}
                    )
            else:
                out.append(
                    {"HBA": [ha1, ha2, ha3], "HBD": [hd], "aromatic": []}
                )
    return out


# =============================================================================
# Checkers (geometry for a CONFIGURATION in a given conformer)
# =============================================================================
def check_k3(
    mol: Chem.Mol,
    dist: Dict[str, float],
    config: Dict[str, List[int]],
    tol_core: float = 1.0,
    tol_ar: float = 2.0,
) -> bool:
    m = Chem.RemoveHs(mol)
    ensure_has_conformer(m)
    conf = m.GetConformer()
    a = config["HBA"][0]
    d = config["HBD"][0]
    ar_list = config.get("aromatic", [])
    if not ar_list:
        return False
    p = {i: _p(conf, i) for i in set([a, d] + ar_list)}
    for r in ar_list:
        if (
            abs(_d(p[a], p[d]) - dist["A_D"]) <= tol_core
            and abs(_d(p[r], p[a]) - dist["R_A"]) <= tol_ar
            and abs(_d(p[r], p[d]) - dist["R_D"]) <= tol_ar
        ):
            return True
    return False


def check_k4_ha2(
    mol: Chem.Mol,
    dist: Dict[str, float],
    config: Dict[str, List[int]],
    tol_core: float = 1.0,
    tol_ar: float = 2.0,
) -> bool:
    m = Chem.RemoveHs(mol)
    ensure_has_conformer(m)
    conf = m.GetConformer()
    ha = config["HBA"]
    d = config["HBD"][0]
    ar_list = config.get("aromatic", [])
    if not ar_list:
        return False
    p = {i: _p(conf, i) for i in set(ha + [d] + ar_list)}

    def core_ok(h1, h2):
        return (
            abs(_d(p[h1], p[h2]) - dist["HA1_HA2"]) <= tol_core
            and abs(_d(p[h1], p[d]) - dist["HA1_HD"]) <= tol_core
            and abs(_d(p[h2], p[d]) - dist["HA2_HD"]) <= tol_core
        )

    order = None
    if core_ok(ha[0], ha[1]):
        order = (ha[0], ha[1])
    elif core_ok(ha[1], ha[0]):
        order = (ha[1], ha[0])
    else:
        return False
    h1, h2 = order
    for r in ar_list:
        if (
            abs(_d(p[r], p[h1]) - dist["Ar_HA1"]) <= tol_ar
            and abs(_d(p[r], p[h2]) - dist["Ar_HA2"]) <= tol_ar
            and abs(_d(p[r], p[d]) - dist["Ar_HD"]) <= tol_ar
        ):
            return True
    return False


def check_k4_ar2(
    mol: Chem.Mol,
    dist: Dict[str, float],
    config: Dict[str, List[int]],
    tol_core: float = 1.0,
    tol_ar: float = 2.0,
) -> bool:
    m = Chem.RemoveHs(mol)
    ensure_has_conformer(m)
    conf = m.GetConformer()
    a = config["HBA"][0]
    d = config["HBD"][0]
    ar1_atoms, ar2_atoms = config["aromatic_pair"]
    p = {i: _p(conf, i) for i in set([a, d] + ar1_atoms + ar2_atoms)}

    def any_match(ar_atoms, key_A, key_D):
        for r in ar_atoms:
            if (
                abs(_d(p[r], p[a]) - dist[key_A]) <= tol_ar
                and abs(_d(p[r], p[d]) - dist[key_D]) <= tol_ar
                and abs(_d(p[a], p[d]) - dist["A_D"]) <= tol_core
            ):
                return True
        return False

    scheme1 = any_match(ar1_atoms, "R1_A", "R1_D") and any_match(
        ar2_atoms, "R2_A", "R2_D"
    )
    scheme2 = any_match(ar1_atoms, "R2_A", "R2_D") and any_match(
        ar2_atoms, "R1_A", "R1_D"
    )
    if not (scheme1 or scheme2):
        return False
    for r1 in ar1_atoms:
        for r2 in ar2_atoms:
            if abs(_d(p[r1], p[r2]) - dist["R1_R2"]) <= tol_ar:
                return True
    return False


def check_k5_ha3(
    mol: Chem.Mol,
    dist: Dict[str, float],
    config: Dict[str, List[int]],
    tol_core: float = 1.0,
    tol_ar: float = 2.0,
) -> bool:
    from itertools import permutations

    m = Chem.RemoveHs(mol)
    ensure_has_conformer(m)
    conf = m.GetConformer()
    ha = config["HBA"]
    d = config["HBD"][0]
    ar_list = config.get("aromatic", [])
    if not ar_list:
        return False
    p = {i: _p(conf, i) for i in set(ha + [d] + ar_list)}
    for H1, H2, H3 in permutations(ha, 3):
        core_ok = (
            abs(_d(p[H1], p[H2]) - dist["HA1_HA2"]) <= tol_core
            and abs(_d(p[H1], p[H3]) - dist["HA1_HA3"]) <= tol_core
            and abs(_d(p[H2], p[H3]) - dist["HA2_HA3"]) <= tol_core
            and abs(_d(p[H1], p[d]) - dist["HA1_HD"]) <= tol_core
            and abs(_d(p[H2], p[d]) - dist["HA2_HD"]) <= tol_core
            and abs(_d(p[H3], p[d]) - dist["HA3_HD"]) <= tol_core
        )
        if not core_ok:
            continue
        for r in ar_list:
            if (
                abs(_d(p[r], p[H1]) - dist["Ar_HA1"]) <= tol_ar
                and abs(_d(p[r], p[H2]) - dist["Ar_HA2"]) <= tol_ar
                and abs(_d(p[r], p[H3]) - dist["Ar_HA3"]) <= tol_ar
                and abs(_d(p[r], p[d]) - dist["Ar_HD"]) <= tol_ar
            ):
                return True
    return False


# =============================================================================
# Plotting
# =============================================================================
def plot_molecule_with_highlights(mol, atom_labels):
    colors = {
        "HBD_label": (1, 0.647, 0),
        "HBA_label": (0, 1, 0),
        "aromatic": (1, 0.75, 0.8),
    }
    mdraw = Chem.Mol(mol)
    rdMolDraw2D.PrepareMolForDrawing(mdraw)

    highlight_atoms, highlight_colors = [], {}
    highlight_bonds, bond_colors = [], {}
    colored_atoms = set()

    # HBD and HBA
    for label in ["HBD_label", "HBA_label"]:
        for atom in atom_labels.get(label, []):
            idx = int(atom)
            highlight_atoms.append(idx)
            highlight_colors[idx] = colors[label]
            colored_atoms.add(idx)

    # Aromatic atoms (not already colored)
    aromatic_atoms = set(int(a) for a in atom_labels.get("aromatic", []))
    for idx in aromatic_atoms:
        if idx not in colored_atoms:
            highlight_atoms.append(idx)
            highlight_colors[idx] = colors["aromatic"]

    # Aromatic bonds
    for bond in mdraw.GetBonds():
        a1, a2 = bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()
        if a1 in aromatic_atoms and a2 in aromatic_atoms:
            bidx = bond.GetIdx()
            highlight_bonds.append(bidx)
            bond_colors[bidx] = colors["aromatic"]

    drawer = rdMolDraw2D.MolDraw2DCairo(400, 400)
    drawer.DrawMolecule(
        mdraw,
        highlightAtoms=highlight_atoms,
        highlightAtomColors=highlight_colors,
        highlightBonds=highlight_bonds,
        highlightBondColors=bond_colors,
    )
    drawer.FinishDrawing()
    return drawer


def plot_match(mol, config, out_png):
    if "aromatic_pair" in config:
        ar = list(set(config["aromatic_pair"][0] + config["aromatic_pair"][1]))
    else:
        ar = config.get("aromatic", [])
    atom_labels = {"HBD_label": config["HBD"], "HBA_label": config["HBA"], "aromatic": ar}
    d = plot_molecule_with_highlights(mol, atom_labels)
    os.makedirs(os.path.dirname(out_png), exist_ok=True)
    with open(out_png, "wb") as f:
        f.write(d.GetDrawingText())


# =============================================================================
# IO utilities
# =============================================================================
def _parse_id_conf_from_name(name: str):
    if not name:
        return None, None
    m = _CONF_RE.match(name)
    if m:
        mol_id, conf_id = m.groups()
        return mol_id, int(conf_id)
    # fallback: split on first '#'
    return (name.split("#", 1)[0]) if "#" in name else name, None


def get_dict_id_with_mol_confs(sdf_path: str):
    """
    Return dict: ID -> [mol_conf0, mol_conf1, ...].
    Each list element is a DIFFERENT conformer (SDF record).
    """
    suppl = Chem.SDMolSupplier(sdf_path, removeHs=False, sanitize=False)
    mol_list = [mol for mol in suppl if mol is not None]

    from collections import defaultdict

    id_to_mols = defaultdict(list)
    for mol in mol_list:
        name = mol.GetProp("_Name") if mol.HasProp("_Name") else ""
        mol_id = mol.GetProp("ID") if mol.HasProp("ID") else None
        if mol_id is None:
            mol_id, _ = _parse_id_conf_from_name(name)
        if mol_id is None:
            continue

        conf_idx = None
        if mol.HasProp("conf_id"):
            try:
                conf_idx = int(mol.GetProp("conf_id"))
            except Exception:
                conf_idx = None
        if conf_idx is None and name:
            _, conf_idx = _parse_id_conf_from_name(name)
        if conf_idx is not None:
            mol.SetIntProp("conf_idx", conf_idx)

        if name:
            mol.SetProp("_orig_name", name)

        id_to_mols[mol_id].append(mol)
    return id_to_mols


def get_smiles_from_mol_list(mol_list):
    """
    Try to get SMILES string from 'smiles' property; if missing,
    sanitize the first mol and generate canonical isomeric SMILES.
    """
    for m in mol_list:
        if m and m.HasProp("smiles"):
            return m.GetProp("smiles")
    try:
        if mol_list:
            m0 = Chem.Mol(mol_list[0])
            Chem.SanitizeMol(m0, catchErrors=True)
            m0 = Chem.RemoveHs(m0)
            return Chem.MolToSmiles(m0, canonical=True, isomericSmiles=True)
    except Exception:
        pass
    return None


def config_signature(config):
    """
    Signature of CONFIGURATION (uniqueness based on chosen atoms, not conformer).
    Used to detect whether we have 0, 1, or >1 distinct pharmacophore matches.
    """

    def norm_list(vals):
        try:
            return tuple(sorted(set(int(v) for v in vals)))
        except Exception:
            try:
                return tuple(sorted(set(int(v[0]) for v in vals)))
            except Exception:
                return tuple()

    if "aromatic_pair" in config:
        a1 = norm_list(config["aromatic_pair"][0])
        a2 = norm_list(config["aromatic_pair"][1])
        return (
            norm_list(config.get("HBA", [])),
            norm_list(config.get("HBD", [])),
            ("pair", a1, a2),
        )
    else:
        return (
            norm_list(config.get("HBA", [])),
            norm_list(config.get("HBD", [])),
            norm_list(config.get("aromatic", [])),
        )


# =============================================================================
# Core builder
# =============================================================================
def build_df_labels_from_sdf(
    sdf_path: str,
    hypothesis_points: Dict[str, List[Tuple[float, float, float]]],
    pharm_kind: str,  # 'k3'|'k4'|'k5'
    tol_core: float = 1.0,
    tol_ar: float = 2.0,
    make_plots: bool = False,
    plots_root: Optional[str] = None,
    max_plots_per_id: int = 10,
    strict: bool = False,
    log_configs: bool = False,
) -> pd.DataFrame:
    logging.info(f"Loading SDF: {sdf_path}")
    validate_runtime_params(tol_core, tol_ar)
    src_path = os.path.abspath(sdf_path)

    # Pharmacophore schema & distances
    if pharm_kind == "k3":
        distances = distances_k3(hypothesis_points)
        enum = enum_k3
        check = check_k3
        k4_variant = None
    elif pharm_kind == "k4":
        n_ha = len(hypothesis_points.get("HBA", []))
        n_ar = len(hypothesis_points.get("aromatic", []))
        if n_ar >= 2 and n_ha >= 1:
            distances = distances_k4_ar2(hypothesis_points)
            enum = enum_k4_ar2
            check = check_k4_ar2
            k4_variant = "2Ar"
        elif n_ha >= 2 and n_ar >= 1:
            distances = distances_k4_ha2(hypothesis_points)
            enum = enum_k4_ha2
            check = check_k4_ha2
            k4_variant = "2HBA"
        else:
            raise PharmacophoreSpecError(
                "k4 needs either (≥1 HBA, ≥1 HBD, ≥2 aromatic) or "
                "(≥2 HBA, ≥1 HBD, ≥1 aromatic)."
            )
    elif pharm_kind == "k5":
        distances = distances_k5_ha3(hypothesis_points)
        enum = enum_k5_ha3
        check = check_k5_ha3
        k4_variant = None
    else:
        raise PharmacophoreSpecError(f"Unknown pharm kind: {pharm_kind}")

    id2mols = get_dict_id_with_mol_confs(sdf_path)
    all_ids = sorted(id2mols.keys())
    tail = f" (k4_variant={k4_variant})" if (pharm_kind == "k4" and k4_variant) else ""
    logging.info(f"Found {len(all_ids)} IDs with conformers. Mode: {pharm_kind}{tail}")

    rows = []
    for i, id_ in enumerate(all_ids, start=1):
        mol_list = id2mols[id_]
        logging.debug(f"[ID={id_}] n_conformers={len(mol_list)}")

        # unique CONFIG signatures across ALL conformers
        seen_signatures = set()
        unique_config_first = None
        winner_conf_id = None
        winner_name = None
        matched_conf_ids = []  # conformers that had at least one match
        plots_done = 0

        for conf_order, mol in enumerate(mol_list):
            name = (
                mol.GetProp("_orig_name")
                if mol.HasProp("_orig_name")
                else (mol.GetProp("_Name") if mol.HasProp("_Name") else "")
            )
            conf_id = mol.GetIntProp("conf_idx") if mol.HasProp("conf_idx") else None
            if conf_id is None and name:
                _, conf_id = _parse_id_conf_from_name(name)

            configs = enum(mol)
            logging.debug(
                f"[ID={id_} | conformer={conf_id} | name='{name}'] "
                f"n_configs={len(configs)}"
            )
            if strict and not configs:
                raise PharmacophoreSpecError(
                    f"No candidate configurations for ID={id_} in mode={pharm_kind}."
                )

            any_match_this_conformer = False
            matched_configs_here = 0

            for config in configs:
                ok = check(mol, distances, config, tol_core=tol_core, tol_ar=tol_ar)

                if log_configs:
                    sig_dbg = config_signature(config)
                    logging.debug(
                        f"[ID={id_} | conformer={conf_id}] "
                        f"CONFIG sig={sig_dbg} => {'MATCH' if ok else 'no match'}"
                    )

                if not ok:
                    continue

                sig = config_signature(config)
                is_dup = sig in seen_signatures
                if not is_dup:
                    seen_signatures.add(sig)
                    matched_configs_here += 1
                    any_match_this_conformer = True

                    if unique_config_first is None:
                        # Remember first UNIQUE match (attributes for CSV)
                        def to_int_list(v):
                            try:
                                return [int(x) for x in v]
                            except Exception:
                                try:
                                    return [int(x[0]) for x in v]
                                except Exception:
                                    return []

                        if "aromatic_pair" in config:
                            ar_for_save = list(
                                set(
                                    config["aromatic_pair"][0]
                                    + config["aromatic_pair"][1]
                                )
                            )
                        else:
                            ar_for_save = config.get("aromatic", [])

                        unique_config_first = {
                            "HBA": to_int_list(config.get("HBA", [])),
                            "HBD": to_int_list(config.get("HBD", [])),
                            "aromatic": to_int_list(ar_for_save),
                        }
                        winner_conf_id = conf_id
                        winner_name = name

                    if log_configs:
                        logging.debug(
                            f"[ID={id_} | conformer={conf_id}] UNIQUE_CONFIG "
                            f"{'(duplicate)' if is_dup else '(NEW)'} | "
                            f"unique_total={len(seen_signatures)}"
                        )

                # Optional plots
                if make_plots and plots_root and plots_done < max_plots_per_id:
                    out_png = os.path.join(plots_root, id_, f"match_{plots_done+1:03d}.png")
                    try:
                        plot_match(mol, config, out_png)
                        plots_done += 1
                    except Exception as e:
                        logging.warning(f"Plot failed for {id_}: {e}")

            if any_match_this_conformer and conf_id is not None:
                matched_conf_ids.append(int(conf_id))

            logging.info(
                f"[ID={id_} | conformer={conf_id}] matched_configs_here={matched_configs_here} | "
                f"unique_configs_total_so_far={len(seen_signatures)}"
            )

        smiles = get_smiles_from_mol_list(mol_list)
        n_confs = len(mol_list)
        n_matches = len(set(matched_conf_ids))
        n_unique = len(seen_signatures)

        # Labeling policy:
        #   - n_unique == 0 => negative (y=0), kept
        #   - n_unique == 1 => positive (y=1), kept
        #   - n_unique > 1  => ambiguous, DROPPED from dataset
        if n_unique == 0:
            # Pure negative (no pharmacophore match)
            rows.append(
                {
                    "ID": id_,
                    "smiles": smiles,
                    "y": 0,
                    "HBA": [],
                    "HBD": [],
                    "aromatic": [],
                    "sdf_source": src_path,
                    "winner_conf_id": None,
                    "winner_name": None,
                    "matched_conf_ids": sorted(set(matched_conf_ids)),
                    "n_confs": n_confs,
                    "n_matches": n_matches,
                }
            )
        elif n_unique == 1:
            # Exactly one unique pharmacophore configuration – positive
            rows.append(
                {
                    "ID": id_,
                    "smiles": smiles,
                    "y": 1,
                    "HBA": unique_config_first.get("HBA", [])
                    if unique_config_first
                    else [],
                    "HBD": unique_config_first.get("HBD", [])
                    if unique_config_first
                    else [],
                    "aromatic": unique_config_first.get("aromatic", [])
                    if unique_config_first
                    else [],
                    "sdf_source": src_path,
                    "winner_conf_id": winner_conf_id,
                    "winner_name": winner_name,
                    "matched_conf_ids": sorted(set(matched_conf_ids)),
                    "n_confs": n_confs,
                    "n_matches": n_matches,
                }
            )
        else:
            # Ambiguous: multiple distinct CONFIG signatures -> drop this ID altogether
            logging.info(
                f"[ID={id_}] Skipping: {n_unique} unique pharmacophore configurations matched."
            )

        if i % 100 == 0 or i == len(all_ids):
            logging.info(f"Processed {i}/{len(all_ids)} IDs")

    df_labels = pd.DataFrame(
        rows,
        columns=[
            "ID",
            "smiles",
            "y",
            "HBA",
            "HBD",
            "aromatic",
            "sdf_source",
            "winner_conf_id",
            "winner_name",
            "matched_conf_ids",
            "n_confs",
            "n_matches",
        ],
    )
    logging.info(
        f"df_labels built: {len(df_labels)} rows "
        f"(y=1: {(df_labels['y'] == 1).sum()}, y=0: {(df_labels['y'] == 0).sum()})"
    )
    return df_labels


# =============================================================================
# Per-SDF wrapper, merging, main
# =============================================================================
def process_one_sdf(
    sdf_path: str,
    hypothesis: Dict,
    pharm_kind: str,
    tol_core: float,
    tol_ar: float,
    make_plots: bool,
    plots_root_for_sdf: str,
    out_csv_for_sdf: str,
    strict: bool = False,
    log_configs: bool = False,
) -> Optional[str]:
    try:
        df = build_df_labels_from_sdf(
            sdf_path=sdf_path,
            hypothesis_points=hypothesis,
            pharm_kind=pharm_kind,
            tol_core=tol_core,
            tol_ar=tol_ar,
            make_plots=make_plots,
            plots_root=plots_root_for_sdf,
            max_plots_per_id=10,
            strict=strict,
            log_configs=log_configs,
        )
        if df is None or df.empty:
            logging.info(
                f"[{os.path.basename(sdf_path)}] No rows to save (empty df_labels)."
            )
            return None
        os.makedirs(os.path.dirname(out_csv_for_sdf), exist_ok=True)
        df.to_csv(out_csv_for_sdf, index=False)
        logging.info(
            f"[{os.path.basename(sdf_path)}] Saved {len(df)} rows -> {out_csv_for_sdf}"
        )
        return out_csv_for_sdf
    except Exception as e:
        logging.exception(f"Failed on {sdf_path}: {e}")
        return None


def merge_part_csvs(part_out_dir: str, out_merged_path: str) -> int:
    files = sorted(glob.glob(os.path.join(part_out_dir, "*_labels.csv")))
    dfs = []
    for f in files:
        try:
            df = pd.read_csv(f)
            if not df.empty:
                dfs.append(df)
        except Exception as e:
            logging.warning(f"Skip {f}: {e}")
    if not dfs:
        logging.info(f"No CSVs to merge in {part_out_dir}.")
        return 0
    cat = pd.concat(dfs, ignore_index=True)
    os.makedirs(os.path.dirname(out_merged_path), exist_ok=True)
    cat.to_csv(out_merged_path, index=False)
    logging.info(
        f"Merged {len(dfs)} files -> {out_merged_path} ({len(cat)} rows)"
    )
    return len(cat)


def main():
    ap = argparse.ArgumentParser(
        description="Build pharmacophore labels for all SDFs in a part directory (parallel)."
    )
    ap.add_argument(
        "--part-dir",
        required=True,
        help="e.g. .../sdf_files/part_000",
    )
    ap.add_argument(
        "--plots-root",
        required=True,
        help="Root for plots; will create part_XXX/<sdf_stem>/<ID>/",
    )
    ap.add_argument(
        "--out-root",
        required=True,
        help="Root for CSV outputs; per SDF and merged per part",
    )
    ap.add_argument(
        "--pharm",
        choices=["k3", "k4", "k5"],
        required=True,
        help="Pharmacophore schema to use.",
    )
    ap.add_argument("--cpus", type=int, default=8)
    ap.add_argument("--tol-core", type=float, default=1.0)
    ap.add_argument("--tol-ar", type=float, default=2.0)
    ap.add_argument(
        "--hypo-json",
        type=str,
        default=None,
        help="Path to hypothesis JSON with HBA/HBD/aromatic.",
    )
    ap.add_argument(
        "--strict",
        action="store_true",
        help="Raise error if a molecule has no candidate configurations.",
    )
    ap.add_argument(
        "--log-level",
        type=str,
        default="INFO",
        help="Python logging level (e.g., DEBUG, INFO).",
    )
    ap.add_argument(
        "--log-configs",
        action="store_true",
        help="Log each configuration check (very verbose).",
    )
    args = ap.parse_args()

    setup_logging(args.log_level)

    part_dir = args.part_dir
    part_name = os.path.basename(part_dir.rstrip("/"))
    os.makedirs(args.plots_root, exist_ok=True)
    os.makedirs(args.out_root, exist_ok=True)

    # Hypothesis
    if args.hypo_json:
        if not os.path.isfile(args.hypo_json):
            logging.error(f"Hypothesis JSON not found: {args.hypo_json}")
            sys.exit(1)
        with open(args.hypo_json, "r") as f:
            hypothesis = json.load(f)
    else:
        hypothesis = {
            "HBA": [[13.62, -35.69, 13.90]],
            "HBD": [[11.27, -35.87, 14.33]],
            "aromatic": [[14.14, -36.57, 12.96]],
        }

    # Normalize hypothesis & alias hydrophobic -> aromatic
    def _as_tuple3(x):
        return (float(x[0]), float(x[1]), float(x[2]))

    def normalize_hypothesis(hypo_raw: Dict) -> Dict[str, List[Tuple[float, float, float]]]:
        out = {"HBA": [], "HBD": [], "aromatic": []}
        for key in ("HBA", "HBD", "aromatic"):
            if key in hypo_raw and isinstance(hypo_raw[key], list):
                out[key] = [_as_tuple3(p) for p in hypo_raw[key]]
        if "hydrophobic" in hypo_raw and isinstance(hypo_raw["hydrophobic"], list):
            out["aromatic"].extend(_as_tuple3(p) for p in hypo_raw["hydrophobic"])
        return out

    hypothesis = normalize_hypothesis(hypothesis)

    # Collect SDFs
    if not os.path.isdir(part_dir):
        logging.error(f"Part directory not found: {part_dir}")
        sys.exit(1)

    sdf_files = sorted(glob.glob(os.path.join(part_dir, "*.sdf")))
    logging.info(f"[{part_name}] Found {len(sdf_files)} SDF files.")
    if not sdf_files:
        logging.warning(f"[{part_name}] No SDFs in {part_dir}.")
        sys.exit(0)

    # Parallel processing of SDFs
    futures = []
    with ProcessPoolExecutor(max_workers=max(1, args.cpus)) as ex:
        for sdf in sdf_files:
            sdf_stem = os.path.splitext(os.path.basename(sdf))[0]
            plots_root_for_sdf = os.path.join(args.plots_root, part_name, sdf_stem)
            out_csv_for_sdf = os.path.join(
                args.out_root, part_name, f"{sdf_stem}_labels.csv"
            )
            futures.append(
                ex.submit(
                    process_one_sdf,
                    sdf,
                    hypothesis,
                    args.pharm,
                    args.tol_core,
                    args.tol_ar,
                    True,
                    plots_root_for_sdf,
                    out_csv_for_sdf,
                    args.strict,
                    args.log_configs,
                )
            )
        done = 0
        for f in as_completed(futures):
            _ = f.result()
            done += 1
            if done % 10 == 0 or done == len(futures):
                logging.info(
                    f"[{part_name}] Progress: {done}/{len(futures)} SDF done"
                )

    # Merge per part
    part_out_dir = os.path.join(args.out_root, part_name)
    out_merged = os.path.join(args.out_root, f"{part_name}_labels_merged.csv")
    merge_part_csvs(part_out_dir, out_merged)


if __name__ == "__main__":
    main()
